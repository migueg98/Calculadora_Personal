<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Cuadrantes Hostelería — Semana</title>
<style>
body{font-family:system-ui,Segoe UI,Arial;margin:20px;max-width:1200px}
input,select,button{font-size:14px;padding:8px;margin:6px 0}
label{font-weight:600;margin-top:12px;display:block}
section.day{border:1px solid #eee;padding:12px;border-radius:10px;margin:10px 0}
section.day h3{margin:0 0 6px 0}
.inline{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.slots{margin-top:8px}
.slot-row{display:flex;gap:10px;align-items:center;padding:6px 0;border-bottom:1px dashed #eee}
.slot-row:last-child{border-bottom:none}
.slot-row label{min-width:120px}
.btns{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
table{border-collapse:collapse;width:100%;margin-top:16px}
th,td{border:1px solid #e3e3e3;padding:8px;text-align:center}
th{background:#fafafa;font-weight:700}
td.emp{font-weight:600;text-align:left}
td.hit{background:#f3fbf3}
.warn{background:#fff9e6;border:1px solid #ffe08a;padding:10px;margin-top:10px;white-space:pre-wrap}
.help{color:#555;font-size:13px;margin:8px 0}
hr{border:none;border-top:1px solid #eee;margin:12px 0}
.small{width:140px}
</style>
</head>
<body>
  <h1>Cuadrantes — Semana (reglas duras)</h1>
  <p class="help">
    Para cada día, elige hasta <b>dos rangos</b> (p. ej. 11–17 y 20–23). El sistema genera <b>todas las franjas posibles</b>
    dentro de esos rangos, con una <b>duración mínima</b> y un <b>paso</b> configurables. Marca qué franjas se usan y el <b>mínimo</b> de personal por franja.
  </p>

  <!-- Config general -->
  <section class="inline" style="justify-content:space-between;align-items:flex-end">
    <div>
      <label>Empleados (IDs separados por coma)</label>
      <input id="emps" style="width:520px" value="E1,E2,E3,E4,E5,E6,E7,E8,E9,E10,E11,E12,E13,E14,E15">
    </div>
    <div>
      <label>Objetivo horas/empleado</label>
      <input id="target" class="small" value="40">
    </div>
    <div>
      <label>Tolerancia ±h</label>
      <input id="tol" class="small" value="2">
    </div>
    <div>
      <label>Máx. horas/día (por empleado)</label>
      <input id="maxDay" class="small" value="9">
    </div>
    <div>
      <label>Permitir turno partido (bloques/día)</label>
      <select id="maxBlocks" class="small">
        <option value="1">No (1 bloque)</option>
        <option value="2" selected>Sí (2 bloques)</option>
      </select>
    </div>
  </section>

  <section class="inline" style="align-items:flex-end">
    <div>
      <label>Duración mínima de franja (horas)</label>
      <input id="minSlotHours" class="small" value="2">
    </div>
    <div>
      <label>Paso para generar marcas (minutos)</label>
      <select id="stepMin" class="small">
        <option value="30">30</option>
        <option value="60" selected>60</option>
        <option value="120">120</option>
      </select>
    </div>
  </section>

  <hr>

  <!-- Días -->
  <div id="days"></div>

  <div class="btns">
    <button id="calcWeek">Calcular semana (reglas duras)</button>
  </div>

  <div id="tableWrap"></div>
  <div id="warnings" class="warn" style="display:none"></div>

<script>
const DAYS_EN = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
const DAYS_ES = ["Lun","Mar","Mié","Jue","Vie","Sáb","Dom"];

// -------- utilidades de tiempo --------
function pad2(n){ return String(n).padStart(2,'0'); }
function normTime(t){
  // acepta "24:00" -> "23:59"
  const [h,m] = t.split(':').map(n=>parseInt(n||'0',10));
  if (h===24 && (m||0)===0) return "23:59";
  return `${pad2(h)}:${pad2(m)}`;
}
function minutes(t){
  const [h,m] = t.split(':').map(Number);
  if (h===24 && m===0) return 24*60-1;
  return h*60+m;
}
function hoursBetween(a,b){
  return Math.max(0,(minutes(b)-minutes(a)))/60.0;
}
function timeList(step=60){
  const out=[];
  for(let m=0;m<=24*60;m+=step){
    let h=Math.floor(m/60), mm=m%60;
    out.push(`${pad2(h)}:${pad2(mm)}`);
  }
  return out;
}
const TIME_OPTIONS = timeList(30); // para selects (más fino)

// -------- UI por día (2 rangos con desplegables) --------
function daySection(dayIdx){
  const en = DAYS_EN[dayIdx], es = DAYS_ES[dayIdx];
  const sec = document.createElement('section');
  sec.className = 'day';
  sec.dataset.day = en;
  sec.innerHTML = `
    <h3>${es} <span style="font-weight:400;color:#777">(${en})</span></h3>
    <div class="inline">
      <label style="min-width:95px">Rango 1</label>
      <select class="s1 small"></select>
      <span>—</span>
      <select class="e1 small"></select>

      <label style="min-width:110px;margin-left:12px">Turno partido</label>
      <input type="checkbox" class="parted" checked>

      <label style="min-width:95px;margin-left:12px">Rango 2</label>
      <select class="s2 small"></select>
      <span>—</span>
      <select class="e2 small"></select>

      <button class="gen">Generar franjas</button>
      <label style="margin-left:10px">Cerrado</label>
      <input type="checkbox" class="closed">
    </div>
    <div class="slots"></div>
  `;

  // Rellenar selects con opciones de tiempo
  for (const cls of ["s1","e1","s2","e2"]){
    const sel = sec.querySelector(`.${cls}`);
    TIME_OPTIONS.forEach(t=>{
      const opt=document.createElement('option');
      opt.value=t; opt.textContent=t;
      sel.appendChild(opt);
    });
  }
  // Defaults típicos
  sec.querySelector('.s1').value = "11:00";
  sec.querySelector('.e1').value = "17:00";
  sec.querySelector('.s2').value = "20:00";
  sec.querySelector('.e2').value = "23:59";

  // Eventos
  const parted = sec.querySelector('.parted');
  const s2 = sec.querySelector('.s2');
  const e2 = sec.querySelector('.e2');
  function toggleSecondRange(){
    const on = parted.checked;
    s2.disabled = e2.disabled = !on;
  }
  toggleSecondRange();
  parted.onchange = toggleSecondRange;

  sec.querySelector('.gen').onclick = ()=> renderSlots(sectionToConfig(sec), sec);
  sec.querySelector('.closed').onchange = ()=>{
    const closed = sec.querySelector('.closed').checked;
    const controls = sec.querySelectorAll('select,button,input[type="checkbox"].parted');
    controls.forEach(el=>{ el.disabled = closed; });
    sec.querySelector('.slots').innerHTML = closed ? '<div style="color:#999">Día cerrado</div>' : '';
  };

  return sec;
}

// Convierte una sección de día a config de ventanas
function sectionToConfig(sec){
  const day = sec.dataset.day;
  const closed = sec.querySelector('.closed').checked;
  if (closed) return {day, closed:true, windows:[]};
  const s1 = normTime(sec.querySelector('.s1').value);
  const e1 = normTime(sec.querySelector('.e1').value);
  const parted = sec.querySelector('.parted').checked;
  const cfg = { day, closed:false, windows: [] };
  if (minutes(e1) > minutes(s1)) cfg.windows.push({start:s1, end:e1});
  if (parted){
    const s2 = normTime(sec.querySelector('.s2').value);
    const e2 = normTime(sec.querySelector('.e2').value);
    if (minutes(e2) > minutes(s2)) cfg.windows.push({start:s2, end:e2});
  }
  return cfg;
}

// Genera todas las franjas posibles dentro de las ventanas, con paso y duración mínima
function generateAllSlots(windows, stepMin, minHours){
  const marks = [];
  for (const w of windows){
    for (let m=minutes(w.start); m<=minutes(w.end); m+=stepMin){
      const h = Math.floor(m/60), mm = m%60;
      const t = `${pad2(h)}:${pad2(mm)}`;
      marks.push(t);
    }
  }
  // marcas únicas ordenadas
  const uniq = Array.from(new Set(marks)).sort((a,b)=>minutes(a)-minutes(b));
  const out = [];
  for (let i=0;i<uniq.length-1;i++){
    for (let j=i+1;j<uniq.length;j++){
      const dur = hoursBetween(uniq[i], uniq[j]);
      if (dur >= minHours){
        // Solo si el intervalo [i,j] está dentro de una de las ventanas (contiguo)
        if (windows.some(w => minutes(uniq[i])>=minutes(w.start) && minutes(uniq[j])<=minutes(w.end))){
          out.push({start:uniq[i], end:uniq[j]});
        }
      }
    }
  }
  return out;
}

function renderSlots(cfg, section){
  const cont = section.querySelector('.slots');
  cont.innerHTML = '';
  if (cfg.closed || !cfg.windows.length){
    cont.innerHTML = '<div style="color:#999">Día cerrado</div>'; return;
  }
  const stepMin = parseInt(document.getElementById('stepMin').value || '60', 10);
  const minSlotHours = parseFloat(document.getElementById('minSlotHours').value || '2');
  const slots = generateAllSlots(cfg.windows, stepMin, minSlotHours);
  if (!slots.length){
    cont.innerHTML = '<div style="color:#999">No hay franjas con esas condiciones.</div>'; return;
  }
  // pintar cada franja con checkbox y mínimo
  for (const sl of slots){
    const row = document.createElement('div');
    row.className = 'slot-row';
    row.innerHTML = `
      <input type="checkbox" class="use">
      <label>${sl.start} — ${sl.end}</label>
      <span>Min:</span>
      <input type="number" class="min" value="0" min="0" style="width:80px">
    `;
    row.dataset.start = sl.start;
    row.dataset.end = sl.end;
    cont.appendChild(row);
  }
}

// -------- construir payload para el solver --------
function collectWeekPayload(){
  const target   = parseFloat(document.getElementById('target').value || '40');
  const tol      = parseFloat(document.getElementById('tol').value || '2');
  const maxDay   = parseFloat(document.getElementById('maxDay').value || '9');
  const maxBlocks= parseInt(document.getElementById('maxBlocks').value || '2',10);
  const empsTxt  = document.getElementById('emps').value.trim();
  const employees = empsTxt.split(',').map(id=>({
    id: id.trim(),
    target_hours: target,
    max_hours_per_day: maxDay,
    max_blocks_per_day: maxBlocks,
    availability: {} // se rellena por día abajo (union de ventanas del día)
  })).filter(e=>e.id);

  const slots = [];
  const mins  = [];

  document.querySelectorAll('section.day').forEach(sec=>{
    const day = sec.dataset.day;
    const closed = sec.querySelector('.closed').checked;
    if (closed) return;

    const cfg = sectionToConfig(sec);
    // disponibilidad = las ventanas del día
    if (cfg.windows.length){
      for (const e of employees){
        e.availability[day] = cfg.windows.map(w=>({start:w.start, end:w.end}));
      }
    }

    // recoger solo las franjas seleccionadas
    const rows = sec.querySelectorAll('.slot-row');
    for (const r of rows){
      const use = r.querySelector('.use').checked;
      if (!use) continue;
      const s = r.dataset.start, e = r.dataset.end;
      const m = parseInt(r.querySelector('.min').value || '0',10);
      slots.push({day, start:s, end:e});
      mins.push(m);
    }
  });

  return {employees, slots, mins, tol};
}

// -------- tabla resultado --------
function renderMatrix(emps, slotsV2, assignments){
  const days = DAYS_EN;
  const mapIdx = Object.fromEntries(emps.map((e,i)=>[e.id,i]));
  const hrs = Array.from({length: emps.length}, ()=>Object.fromEntries(days.map(d=>[d,0])));
  const total = new Array(emps.length).fill(0);

  for (let i=0;i<assignments.length;i++){
    const slot = slotsV2[i];
    const dur = hoursBetween(slot.start, slot.end);
    for (const empId of assignments[i]){
      const r = mapIdx[empId];
      if (r===undefined) continue;
      hrs[r][slot.day] += dur;
      total[r] += dur;
    }
  }

  let html = '<table><thead><tr><th>Empleado</th>';
  for (let c=0;c<days.length;c++) html += `<th>${DAYS_ES[c]}</th>`;
  html += '<th>Total</th></tr></thead><tbody>';

  for (let r=0;r<emps.length;r++){
    html += `<tr><td class="emp">${emps[r].id}</td>`;
    for (let c=0;c<days.length;c++){
      const v = hrs[r][days[c]];
      const txt = v>0 ? v.toFixed(1) : '';
      const cls = v>0 ? ' class="hit"' : '';
      html += `<td${cls}>${txt}</td>`;
    }
    html += `<td><b>${total[r].toFixed(1)}</b></td></tr>`;
  }
  html += '</tbody></table>';
  document.getElementById('tableWrap').innerHTML = html;
}

// -------- init --------
(function init(){
  const wrap = document.getElementById('days');
  for (let i=0;i<DAYS_EN.length;i++){
    const sec = daySection(i);
    wrap.appendChild(sec);
    // genera franjas por defecto
    renderSlots(sectionToConfig(sec), sec);
  }
})();

// -------- calcular --------
document.getElementById('calcWeek').onclick = async () => {
  const {employees, slots, mins, tol} = collectWeekPayload();
  if (!slots.length){
    alert('No hay franjas seleccionadas en la semana.');
    return;
  }
  if (mins.length !== slots.length){
    alert('Alguna franja no tiene mínimo válido.');
    return;
  }
  const payload = { slots, min_per_slot: mins, employees, tolerance: tol };
  const res = await fetch('/solve/greedy_v2', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify(payload)
  });
  const data = await res.json();

  renderMatrix(employees, slots, data.assignments || []);
  const warnBox = document.getElementById('warnings');
  if (data.warnings && data.warnings.length){
    warnBox.style.display = '';
    warnBox.textContent = data.warnings.join('\n');
  } else {
    warnBox.style.display = 'none';
    warnBox.textContent = '';
  }
};
</script>
</body>
</html>
