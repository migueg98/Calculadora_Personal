<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Cuadrantes — Wizard compacto</title>
<style>
:root{--w:1100px}
*{box-sizing:border-box}
body{font-family:system-ui,Segoe UI,Arial;margin:24px;max-width:var(--w)}
h1{margin:0 0 12px}
small.help{color:#555}
.step{border:1px solid #eee;border-radius:12px;padding:16px;margin:14px 0}
.row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
.col{display:flex;flex-direction:column;gap:6px}
label{font-weight:600}
select,input,button{font-size:14px;padding:8px}
select,input{min-width:110px}
table{border-collapse:collapse;width:100%;margin-top:16px}
th,td{border:1px solid #e3e3e3;padding:8px;text-align:center}
th{background:#fafafa}
.badge{display:inline-block;background:#eef7ff;border:1px solid #d8ebff;border-radius:6px;padding:2px 6px;margin-left:6px;color:#175f9e}
.warn{background:#fff3f3;border:1px solid #ffb5b5;padding:10px;border-radius:8px;margin-top:10px;white-space:pre-wrap}
.ok{background:#f3fff3;border:1px solid #b8e6b8;padding:8px;border-radius:8px;margin-top:10px}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
.small{width:110px}
.nowrap{white-space:nowrap}
</style>
</head>
<body>
<h1>Cuadrantes — Configuración</h1>

<!-- Paso 1: Horario del restaurante -->
<div class="step" id="step1">
  <h3>Paso 1 · Horario del restaurante (compacto)</h3>
  <small class="help">Dos rangos por día (comida/cena). Granularidad fija: <b>60 min</b>.</small>

  <div class="row">
    <div class="col">
      <label>Duración mínima de franja (h)</label>
      <select id="minSlotH">
        <option>1</option><option selected>2</option><option>3</option><option>4</option>
        <option>5</option><option>6</option><option>7</option><option>8</option>
      </select>
    </div>
    <div class="col">
      <label>Empleados (IDs, coma)</label>
      <input id="emps" value="E1,E2,E3,E4,E5,E6,E7,E8,E9,E10" />
    </div>
  </div>

  <table id="schedTbl">
    <thead>
      <tr>
        <th>Día</th>
        <th>R1 Inicio</th><th>R1 Fin</th>
        <th class="nowrap">Turno partido</th>
        <th>R2 Inicio</th><th>R2 Fin</th>
      </tr>
    </thead>
    <tbody id="schedBody"></tbody>
  </table>

  <div class="row" style="justify-content:space-between;align-items:center">
    <div class="row">
      <button id="copyMon">Copiar Lunes al resto</button>
    </div>
    <div class="row">
      <button id="genCatalog">Generar catálogo común de franjas</button>
      <span class="badge" id="kpiCat">—</span>
    </div>
  </div>

  <div id="catalogBox" class="ok" style="display:none"></div>
</div>

<!-- Paso 2: Demanda por tramos (opcional) -->
<div class="step" id="step2">
  <h3>Paso 2 · Demanda por tramos (opcional)</h3>
  <small class="help">
    Si no configuras nada aquí, se usará por defecto el <b>máximo personal posible (nº de empleados)</b> en cada hora del día.
    Abre un día y ajusta mínimos por <b>tramos de 1 h</b> si lo necesitas.
  </small>

  <div id="demandWrap"></div>
</div>

<!-- Paso 3: Reglas y cálculo -->
<div class="step" id="step3">
  <h3>Paso 3 · Reglas del personal y cálculo</h3>
  <div class="row">
    <div class="col">
      <label>Objetivo horas/empleado</label>
      <select id="target"><option>20</option><option>30</option><option selected>40</option><option>45</option></select>
    </div>
    <div class="col">
      <label>Tolerancia ±h</label>
      <select id="tol"><option>0</option><option selected>2</option><option>3</option><option>4</option></select>
    </div>
    <div class="col">
      <label>Turno partido (bloques/día)</label>
      <select id="allowSplit"><option value="1">No (1)</option><option value="2" selected>Sí (2)</option></select>
    </div>
    <div class="col">
      <label>Mín horas/día</label>
      <select id="minDay"><option>2</option><option selected>3</option><option>4</option></select>
    </div>
    <div class="col">
      <label>Máx horas/día</label>
      <select id="maxDay"><option>8</option><option selected>9</option><option>10</option></select>
    </div>
    <div class="col">
      <label>Descanso entre bloques (h)</label>
      <select id="minRest"><option>2</option><option selected>3</option><option>4</option></select>
    </div>
    <div class="col">
      <label>Semanas</label>
      <select id="weeks"><option>1</option><option selected>2</option><option>3</option><option>4</option></select>
    </div>
  </div>

  <div class="row">
    <button id="run">Generar cuadrante</button>
  </div>

  <div id="impossible" class="warn" style="display:none"></div>
  <div id="tableWrap"></div>
</div>

<script>
/* ---------- Utilidades ---------- */
const DAYS_EN=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"];
const DAYS_ES=["Lun","Mar","Mié","Jue","Vie","Sáb","Dom"];
function pad2(n){return String(n).padStart(2,'0')}
function minutes(t){let [h,m]=t.split(":").map(Number); if(h===24&&m===0) return 24*60-1; return h*60+m;}
function hoursBetween(a,b){return Math.max(0,(minutes(b)-minutes(a)))/60.0}
function timeOptions60(){const out=[]; for(let h=0;h<=24;h++){out.push(`${pad2(h)}:00`)} return out}
function empCount(){return (document.getElementById('emps').value||'').split(',').map(x=>x.trim()).filter(Boolean).length}

/* ---------- Paso 1: horario compacto ---------- */
function buildScheduleTable(){
  const tbody=document.getElementById('schedBody');
  tbody.innerHTML='';
  const opts=timeOptions60();
  for(let i=0;i<7;i++){
    const tr=document.createElement('tr'); tr.dataset.day=DAYS_EN[i];
    tr.innerHTML=`
      <td>${DAYS_ES[i]} <span class="mono" style="color:#777">(${DAYS_EN[i]})</span></td>
      <td><select class="s1">${opts.map(o=>`<option>${o}</option>`).join('')}</select></td>
      <td><select class="e1">${opts.map(o=>`<option>${o}</option>`).join('')}</select></td>
      <td>
        <select class="parted small">
          <option>No</option><option selected>Sí</option>
        </select>
      </td>
      <td><select class="s2">${opts.map(o=>`<option>${o}</option>`).join('')}</select></td>
      <td><select class="e2">${opts.map(o=>`<option>${o}</option>`).join('')}</select></td>
    `;
    tbody.appendChild(tr);
  }
  // defaults razonables
  [...tbody.querySelectorAll('tr')].forEach(tr=>{
    tr.querySelector('.s1').value="11:00";
    tr.querySelector('.e1').value="17:00";
    tr.querySelector('.s2').value="20:00";
    tr.querySelector('.e2').value="23:00";
    toggleSecondRange(tr);
    tr.querySelector('.parted').onchange=()=>toggleSecondRange(tr);
  });
}
function toggleSecondRange(tr){
  const on = tr.querySelector('.parted').value==="Sí";
  tr.querySelector('.s2').disabled=!on;
  tr.querySelector('.e2').disabled=!on;
}
buildScheduleTable();

document.getElementById('copyMon').onclick=()=>{
  const rows=[...document.querySelectorAll('#schedBody tr')];
  const m=rows[0];
  for(const tr of rows.slice(1)){
    tr.querySelector('.s1').value=m.querySelector('.s1').value;
    tr.querySelector('.e1').value=m.querySelector('.e1').value;
    tr.querySelector('.parted').value=m.querySelector('.parted').value;
    tr.querySelector('.s2').value=m.querySelector('.s2').value;
    tr.querySelector('.e2').value=m.querySelector('.e2').value;
    toggleSecondRange(tr);
  }
}

/* ---------- Catálogo común ---------- */
let catalog=[]; // {start,end,durH,use}
function scheduleWindowsForDay(enDay){
  const tr=[...document.querySelectorAll('#schedBody tr')].find(r=>r.dataset.day===enDay);
  const s1=tr.querySelector('.s1').value, e1=tr.querySelector('.e1').value;
  const parted=tr.querySelector('.parted').value==="Sí";
  const s2=tr.querySelector('.s2').value, e2=tr.querySelector('.e2').value;
  const wins=[]; if(minutes(e1)>minutes(s1)) wins.push({start:s1,end:e1});
  if(parted && minutes(e2)>minutes(s2)) wins.push({start:s2,end:e2});
  return wins;
}
function generateCatalog(){
  const minH=parseFloat(document.getElementById('minSlotH').value||'2');
  const marks=new Set();
  // marcas globales (cada hora a :00) en todas las ventanas
  for(const d of DAYS_EN){
    for(const w of scheduleWindowsForDay(d)){
      for(let m=minutes(w.start); m<=minutes(w.end); m+=60){
        const h=Math.floor(m/60), mm=m%60; marks.add(`${pad2(h)}:${pad2(mm)}`);
      }
    }
  }
  const all=[...marks].sort((a,b)=>minutes(a)-minutes(b));
  const set=new Map();
  for(let i=0;i<all.length-1;i++){
    for(let j=i+1;j<all.length;j++){
      const a=all[i], b=all[j];
      const dur=hoursBetween(a,b);
      if(dur<minH) continue;
      // Debe caber en al menos un día
      const fits=DAYS_EN.some(day=> scheduleWindowsForDay(day).some(w=>minutes(a)>=minutes(w.start)&&minutes(b)<=minutes(w.end)));
      if(!fits) continue;
      set.set(a+"_"+b,{start:a,end:b,durH:dur,use:true}); // por defecto TODO marcado
    }
  }
  catalog=[...set.values()].sort((x,y)=> minutes(x.start)-minutes(y.start) || minutes(x.end)-minutes(y.end));
  // KPI
  const k=document.getElementById('kpiCat');
  k.textContent = catalog.length ? `${catalog.length} franjas (media ${(catalog.reduce((s,x)=>s+x.durH,0)/catalog.length).toFixed(2)}h)` : '—';
  const box=document.getElementById('catalogBox');
  box.style.display='';
  box.textContent = catalog.length ? 'Catálogo generado y seleccionado al completo.' : 'No hay franjas con esta duración mínima.';
}
document.getElementById('genCatalog').onclick=generateCatalog;

/* ---------- Paso 2: Demanda por tramos (1h) ---------- */
const demandPerDay = Object.fromEntries(DAYS_EN.map(d=>[d,new Map()])); // Map("HH:00-HH+1:00" -> min)

function buildDemandUI(){
  const wrap=document.getElementById('demandWrap'); wrap.innerHTML='';
  for(let i=0;i<7;i++){
    const day=DAYS_EN[i], es=DAYS_ES[i];
    const details=document.createElement('details'); details.innerHTML=`<summary>${es} <span class="mono" style="color:#777">(${day})</span></summary>`;
    const inner=document.createElement('div'); inner.className='row'; inner.style.flexDirection='column';
    // botones rápidos
    const btns=document.createElement('div'); btns.className='row';
    const bMax=document.createElement('button'); bMax.textContent='Rellenar máximos';
    const bZero=document.createElement('button'); bZero.textContent='Poner 0';
    btns.appendChild(bMax); btns.appendChild(bZero);
    inner.appendChild(btns);
    // lista de tramos de 1 hora del día (según sus ventanas)
    const tbl=document.createElement('table');
    tbl.innerHTML=`<thead><tr><th>Tramo 1h</th><th>Mínimo</th></tr></thead><tbody></tbody>`;
    const tb=tbl.querySelector('tbody');
    const wins=scheduleWindowsForDay(day);
    const rows=[];
    for(const w of wins){
      for(let t=minutes(w.start); t<minutes(w.end); t+=60){
        const a=`${pad2(Math.floor(t/60))}:00`;
        const b=`${pad2(Math.floor((t+60)/60))}:00`;
        const key=`${a}-${b}`;
        if(!demandPerDay[day].has(key)) demandPerDay[day].set(key, NaN); // NaN = sin tocar => usará por defecto nº empleados
        const tr=document.createElement('tr');
        const td1=document.createElement('td'); td1.textContent=key;
        const td2=document.createElement('td'); 
        const sel=document.createElement('select');
        // opciones 0..#empleados (y quizá más)
        const N=Math.max(empCount(), 20); // tope visual
        for(let k=0;k<=N;k++){ const opt=document.createElement('option'); opt.value=String(k); opt.textContent=String(k); sel.appendChild(opt); }
        // si ya tiene valor, selecciónalo
        const cur=demandPerDay[day].get(key);
        if(!Number.isNaN(cur)) sel.value=String(cur);
        sel.onchange=()=> demandPerDay[day].set(key, parseInt(sel.value,10));
        td2.appendChild(sel);
        tr.appendChild(td1); tr.appendChild(td2);
        tb.appendChild(tr);
        rows.push(sel);
      }
    }
    bMax.onclick=()=>{ const n=empCount(); rows.forEach(sel=> sel.value=String(n)); rows.forEach(sel=> sel.dispatchEvent(new Event('change'))); };
    bZero.onclick=()=>{ rows.forEach(sel=> sel.value='0'); rows.forEach(sel=> sel.dispatchEvent(new Event('change'))); };
    inner.appendChild(tbl);
    details.appendChild(inner);
    wrap.appendChild(details);
  }
}
buildDemandUI();

// si cambia el horario o empleados, conviene regenerar la demanda visible
document.getElementById('emps').addEventListener('input', ()=>buildDemandUI());
document.getElementById('schedBody').addEventListener('change', (e)=>{
  if(e.target.tagName==='SELECT') { buildDemandUI(); }
});

/* ---------- Construcción del payload ---------- */
function employeesObj(){
  const ids=(document.getElementById('emps').value||'').split(',').map(x=>x.trim()).filter(Boolean);
  const target=parseFloat(document.getElementById('target').value||'40');
  const tol=parseFloat(document.getElementById('tol').value||'2');
  const maxBlocks=parseInt(document.getElementById('allowSplit').value||'2',10);
  const minDay=parseFloat(document.getElementById('minDay').value||'3');
  const maxDay=parseFloat(document.getElementById('maxDay').value||'9');
  const minRest=parseFloat(document.getElementById('minRest').value||'3');
  return {
    ids, target, tol, maxBlocks, minDay, maxDay, minRest,
    toList(){
      return ids.map(id=>({
        id,
        target_hours: target,
        max_blocks_per_day: maxBlocks,
        min_hours_per_day: minDay,
        max_hours_per_day: maxDay,
        min_rest_between_blocks: minRest,
        availability: Object.fromEntries(DAYS_EN.map(d=>[d, scheduleWindowsForDay(d)]))
      }));
    }
  };
}
function slotsSelectedForDay(day){
  const wins=scheduleWindowsForDay(day);
  const fits = (s)=> wins.some(w=> minutes(s.start)>=minutes(w.start) && minutes(s.end)<=minutes(w.end));
  return catalog.filter(s=> s.use && fits(s)).map(s=>({day, start:s.start, end:s.end}));
}
function minForSlotFromHourly(slot, day, defaultMin){
  // para el slot [start,end], miramos las horas enteras dentro y tomamos el máximo
  let maxm = 0, found=false;
  for(let t=minutes(slot.start); t<minutes(slot.end); t+=60){
    const a=`${pad2(Math.floor(t/60))}:00`;
    const b=`${pad2(Math.floor((t+60)/60))}:00`;
    const key=`${a}-${b}`;
    if(demandPerDay[day].has(key)){
      const v=demandPerDay[day].get(key);
      if(Number.isNaN(v)) { maxm = Math.max(maxm, defaultMin); } else { maxm = Math.max(maxm, v); }
      found = true;
    }
  }
  if(!found) return defaultMin;
  return maxm;
}
function buildPayload(){
  const emps=employeesObj();
  if(emps.ids.length===0){ throw new Error('Necesitas al menos 1 empleado'); }
  if(catalog.length===0){ throw new Error('Genera primero el catálogo de franjas'); }

  const slots=[]; const mins=[];
  for(const d of DAYS_EN){
    const sel=slotsSelectedForDay(d);
    for(const s of sel){
      const m = minForSlotFromHourly(s, d, emps.ids.length); // por defecto: máximo personal = nº empleados
      slots.push(s);
      mins.push(m);
    }
  }
  return {
    weeks: parseInt(document.getElementById('weeks').value||'2',10),
    tolerance: emps.tol,
    employees: emps.toList(),
    slots, min_per_slot: mins
  };
}

/* ---------- Render de resultado (horarios por celda) ---------- */
function mergeIntervals(intervals){
  // intervals: [{start,end}] HH:MM contiguos -> agrupa
  if(!intervals.length) return [];
  const toMin=(t)=>minutes(t);
  const arr=intervals.slice().sort((a,b)=> toMin(a.start)-toMin(b.start));
  const out=[{...arr[0]}];
  for(let i=1;i<arr.length;i++){
    const prev=out[out.length-1], cur=arr[i];
    if(prev.end===cur.start){ // contiguo
      prev.end=cur.end;
    }else{
      out.push({...cur});
    }
  }
  return out;
}
function renderScheduleTable(empsList, slots, assignments){
  // mapa emp -> día -> intervalos
  const map = {};
  for(const e of empsList){ map[e.id]=Object.fromEntries(DAYS_EN.map(d=>[d,[]])); }
  for(let i=0;i<assignments.length;i++){
    const slot=slots[i];
    for(const eid of assignments[i]||[]){
      if(map[eid]) map[eid][slot.day].push({start:slot.start, end:slot.end});
    }
  }
  // fusionar contiguos y formatear
  const fmt=(ivs)=> mergeIntervals(ivs).map(r=>`${r.start}–${r.end}`).join(', ');
  // totales por empleado
  const dur=(s)=>hoursBetween(s.start,s.end);
  const totalHours=(ivs)=> mergeIntervals(ivs).reduce((acc,r)=> acc+dur(r), 0);

  let html='<table><thead><tr><th>Empleado</th>';
  for(const d of DAYS_ES) html+=`<th>${d}</th>`;
  html+='<th>Total h</th></tr></thead><tbody>';

  for(const e of empsList){
    html+=`<tr><td><b>${e.id}</b></td>`;
    let tot=0;
    for(const day of DAYS_EN){
      const ivs=map[e.id][day];
      const txt=fmt(ivs) || '—';
      const th=totalHours(ivs); tot+=th;
      html+=`<td>${txt}</td>`;
    }
    html+=`<td class="mono">${tot.toFixed(1)}</td></tr>`;
  }
  html+='</tbody></table>';
  document.getElementById('tableWrap').innerHTML=html;
}

/* ---------- Cálculo ---------- */
document.getElementById('run').onclick=async ()=>{
  try{
    const payload=buildPayload();

    // Repetir semanas (si >1): duplicamos arrays (misma semana repetida).
    const n=payload.weeks;
    if(n>1){
      const repSlots=[], repMins=[];
      for(let k=0;k<n;k++){ repSlots.push(...payload.slots); repMins.push(...payload.min_per_slot); }
      payload.slots=repSlots; payload.min_per_slot=repMins;
    }

    const res=await fetch('/solve/greedy_v2',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
    const data=await res.json();

    // Comprobar factibilidad: ninguna franja con déficit.
    let feasible=true, msgs=[];
    for(let i=0;i<payload.slots.length;i++){
      const need=payload.min_per_slot[i];
      const got=(data.assignments && data.assignments[i]) ? data.assignments[i].length : 0;
      if(got<need){ feasible=false; const s=payload.slots[i]; msgs.push(`Déficit ${s.day} ${s.start}-${s.end}: ${got}/${need}`); }
    }

    const imp=document.getElementById('impossible');
    const table=document.getElementById('tableWrap');

    if(!feasible){
      table.innerHTML='';
      imp.style.display='';
      imp.textContent="IMPOSSIBLE: no se puede cuadrar con la demanda actual.\n\nDetalle:\n"+msgs.join('\n');
      return;
    }else{
      imp.style.display='none';
      imp.textContent='';
    }

    // Renderizar tabla con HORARIOS por celda
    renderScheduleTable(payload.employees, payload.slots, data.assignments||[]);

  }catch(err){
    document.getElementById('impossible').style.display='';
    document.getElementById('impossible').textContent = 'Error: '+(err.message||String(err));
  }
};
</script>
</body>
</html>
